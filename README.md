# Использование низкоуровневого машинного кода для оптимизации хеш-таблицы

## Постановка задачи:
Имеется большой набор слов. Требуется уметь загрузить все слова в структуру данных, а потом быстро и много отвечать на запросы, сколько раз встречалось слово в исходном тексте. Также желательно иметь итераторный доступ ко всем словам (необязательно упорядоченный).
Длина слова до 32.

### Решение
Принято решение использовать хеш-таблицу со вторичной структурой данных (СД), ввиду хороший временных показателей.
Принято решение использовать общий односвязный список с фиктивными элементами в качестве разделителей.

## Начало
Был написан первый вариант хеш-таблицы и сгенерирован набор тестов.
В качестве хеш-функции для начала выбрали rotHash (нет).
Итоговые результаты удручают:
общее время - 4 минуты 5 секунд.

### Хеш-тест
Возникло предположение, что использованная хеш-функция плохая как по времени, так и по распределению данных по таблице.
Для сравнения с другими хеш-функциями были отобраны 6 функций и с ними проведен спектральный тест. (Для этого размер таблицы уменьшен в 10 раз).
1. return const 1
2. s[0]
3. sum(s[i])
4. strlen(s)
5. rotl hash
6. встроенный crc32

![Results](Results.png "Результат")
![Plots](Plots.png "Графики")

Действительно, rot_hash слишком кластеризует данные и долго работает.
Был выбран crc32, как наименее кластеризующий, пусть и не самый быстрый.

Для реализации crc32 были выбраны intrinsics, как дающие самый лаконичный код, без потери производительности.

Итого crc32 + intrinsics = 29 с
### ...Ещё больше оптимизаций!

Далее в попытках узнать, можно ли ещё соптимизировать, получен временной профиль программы.

![Profile1](Profile1.png "Profile1")
*См. результаты профилирования в папке stats.*


Оказалось, что почти 30% времени занимает strncmp.
> Значит он такой хороший, ничего не трогаем... (c) Random non-ICT student.

Нет. А то засмеют. Хаха. Очень смешно.

Заметим, что слова до 32 идеально лезут в 256-регистр.
Используем это и пишем cmp... И удивляемся. Всего 15 с вместо 19.

<!-- Также было обнаружено, что автор идиот... -->
<!-- *Когда у тебя компаратор неправильный, то и программа летает за 0.7с.* -->
### Ещё
Также были предприняты другие попытки оптимизации, но они или давали прирост менее чем на 1% или вообще ухудшали время работы. Более того, согласно профилированию, самой нагруженной частью является if, отвечающий за проверку результата сравнения строк.

В том числе были попытки(неудачные) соптимизировать memcpy, memset и пр.

Итоговый КПД (Коэффициент производительности Дединского):

КПД = (16 / 4) * 1000 = 4000.